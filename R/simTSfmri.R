
#' Simulate fMRI time series
#' 
#' Simulates an fMRI time series for the specified design and noise type.
#' 
#' @export
#' @importFrom dplyr mutate select starts_with %>%
#' 
#' @param design List generated by \code{\link{simprepTemporal}} specifying the design.
#' If not specified, noise time series are generated.
#' @param base Baseline value of the time series.
#' @param nscan Number of scans.
#' @param TR Repetition time in seconds.
#' @param SNR Signal-to-noise ratio of the time series.
#' @param noise Type of noise (defaults to \code{"white"}).
#' @param type If \code{noise=="white"}, \code{noise=="task-related"} or \code{noise=="mixture"},
#' type of system noise (defaults to \code{"gaussian"}).
#' @param weights If \code{noise=="mixture"}, vector of weights with 5 elements to specify
#' the fraction of the noise components.
#' @param verbose Logical indicating if warnings should be returned.
#' @param rho If \code{noise=="temporal"} or \code{noise=="mixture"}, value of autocorrelation coefficients.
#' The length of the vector indicates the order of the autoregressive model.
#' @param freq.low If \code{noise=="low-frequency"} or \code{noise=="mixture"}, frequency of the
#' low-frequency drift in seconds.
#' @param freq.heart If \code{noise=="physiological"} or \code{noise=="mixture"}, frequency of
#' heart rate in Hz.
#' @param freq.resp If \code{noise=="physiological"} or \code{noise=="mixture"}, frequency of
#' respiratory rate in Hz.
#' @param vee If \code{type=="rician"}, non-centrality parameter of the distribution.
#' @return A vector representing the fMRI time series.
#' 
#' @seealso \code{\link{simVOLfmri}}, \code{\link{simprepTemporal}}
#' 
#' @examples
#' design <- simprepTemporal(totaltime=200, onsets=seq(1,200,40),
#' durations=20, effectsize=1, TR=2, hrf="double-gamma")
#' ts <- simTSfmri(design=design, SNR=1, noise="white")
#' \dontshow{rm(design,ts)}
#' 
#' @keywords high-level

simTSfmri <- function(design=list(), base=0, nscan=NULL, TR=NULL, SNR=NULL, noise=c("none", "white", "temporal", "low-frequency", "physiological", "task-related", "mixture"), type=c("gaussian","rician"), weights, verbose=TRUE, rho=0.2, freq.low=128, freq.heart=1.17, freq.resp=0.2, vee=1){
  
  if(missing(noise)) noise <- "white"
  
  if(missing(type)) type <- "gaussian"
  
  if(noise=="mixture"){
    if(missing(weights)){
      stop("Weights should be provided with noise=mixture.")
    }
    if(length(weights)!=5){
      stop("Weights vector should have 5 elements.")
    }
    if(sum(weights)!=1){
      stop("The sum of the weights vector should be equal to 1.")
    }
  }
  
  if (is.null(SNR)) stop("SNR not specified, with no default.")
  
  # Might deprecate the case where a design object isn't specified
  if(length(design)==0){
    act <- base
    sigma <- mean(act)/SNR
    if(is.null(TR)){
      stop("TR value is missing.")
    }
    if(is.null(nscan)){
      stop("nscan value is missing.")
    }
  } else if(length(design)>1){
    stop("Multiple regions are undefined for time series.")
  } else {
    convs <- specifydesign(stimfunction(design[[1]]$totaltime, design[[1]]$onsets, design[[1]]$durations, accuracy = design[[1]]$acc),
                           TR = design[[1]]$TR,
                           effectsize = design[[1]]$effectsize,
                           conv = design[[1]]$hrf,
                           param = design[[1]]$param) %>%
      mutate(act = base + rowSums(select(., starts_with("conv."))))
    
    sigma <- mean(convs$act)/SNR
    TR <- design[[1]]$TR
    nscan <- design[[1]]$totaltime/design[[1]]$TR
  }
  
  # Cannot use case_when, regrettably, because it requires all conditions to be evaluable
  # which is not always true
  if (noise == "none") n <- 0
  # why is this wrapped in a c() call? inspect the type of the output of systemnoise()
  # the noise functions output an array with nrow = dim. c() coerces it to a vector when dim = 1
  # TODO: Either remove verbose args from noise functions or add print functionality
  if (noise == "white") n <- c(systemnoise(dim=1, sigma=sigma, nscan=nscan, type=type, verbose=verbose, vee=vee))
  if (noise == "temporal") n <- c(temporalnoise(dim=1, sigma=sigma, nscan=nscan, rho=rho, verbose=verbose))
  if (noise == "low-frequency") n <- c(lowfreqdrift(dim=1, freq=freq.low, nscan=nscan, TR=TR, verbose=verbose))
  if (noise == "physiological") n <- c(physnoise(dim=1, sigma=sigma, nscan=nscan, TR=TR, freq.heart=freq.heart, freq.resp=freq.resp, verbose=verbose))
  if (noise == "task-related") n <- c(tasknoise(act.image=convs$act, sigma=sigma, type=type, vee=vee))
  if (noise=="mixture") {
    # yes, now they're all calculated even ifthe weight was 0; I think this function wasn't that slow to begin with
    # so hopefully the system time issue won't be turrible
    
    n.white <- c(systemnoise(dim=1, sigma=sigma, nscan=nscan, type=type, verbose=verbose, vee=vee))
    n.temp <- c(temporalnoise(dim=1, sigma=sigma, nscan=nscan, rho=rho, verbose=verbose))
    n.low <- c(lowfreqdrift(dim=1, freq=freq.low, nscan=nscan, TR=TR, verbose=verbose))
    n.phys <- c(physnoise(dim=1, sigma=sigma, nscan=nscan, TR=TR, freq.heart=freq.heart, freq.resp=freq.resp, verbose=verbose))
    n.task <- c(tasknoise(act.image=convs$act, sigma=sigma, type=type, vee=vee))
    
    w <- weights
    n <- (w[1]* n.white + w[2]*n.temp + w[3]*n.low + w[4]*n.phys + w[5]*n.task)/sqrt(sum(w^2))
  }
  
  convs <- convs %>%
    mutate(noise = n,
           ts = act + noise - mean(noise)) %>%
    select(-act, -noise)
  
  return(convs)
}

